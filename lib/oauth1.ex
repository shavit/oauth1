defmodule OAuth1 do
  @moduledoc """
  Documentation for Oauth1.
  """

  defmodule Credentials do
    defstruct [
      consumer_key: System.get_env("CONSUMER_KEY"),
      consumer_secret: System.get_env("CONSUMER_SECRET"),
      access_token: System.get_env("ACCESS_TOKEN"),
      access_token_secret: System.get_env("ACCESS_TOKEN_SECRET"),
    ]
  end

  defmodule Headers do
    defstruct [
      oauth_consumer_key: "",
      oauth_nonce: "",
      oauth_signature_method: "HMAC-SHA1",
      oauth_timestamp: "",
      oauth_token: "",
      oauth_version: "1.0"
    ]
  end

  @doc """
  Generates authorization header string

    ## Example:

    generate_authorization_headers(....)
    OAuth oauth_consumer_key="...

    This header is the value for the Authorization header, which every request
      should have:

    ..
    `Authorization: OAuth oauth_consumer_key="`
    ..
  """
  @spec generate_authorization_headers(String.t, String.t, Credentials.t, Map.t) :: String.t
  def generate_authorization_headers(method, url, creds, opts \\ %{}) do
    auth_headers = %Headers{oauth_consumer_key: creds.consumer_key,
        oauth_nonce: oauth_nonce(),
        oauth_timestamp: timestamp(),
        oauth_token: creds.access_token}

    params = auth_headers
      |> Map.merge(opts)
      |> Map.from_struct

    base_string = signature_base_string(method, url, collect_parameters(params))
    signature = calculate_signature(generate_signing_key(creds.consumer_secret,
      creds.access_token_secret), base_string)

    authorize_request_headers(auth_headers,
      encode(signature),
      creds.access_token)
      |> build_header_string
  end

  @doc """
  Gather all the parameters included in the request.
  """
  @spec collect_parameters(Map.t) :: String.t
  def collect_parameters(params) do
    params
    |> Enum.map(fn x ->
      encode(to_string(elem(x, 0))) <> "=" <> encode(to_string(elem(x, 1)))
    end)
    |> Enum.join("&")
  end

  @doc """
  Encode the HTTP method, base URL and parameters (string)
    into a single string.
  """
  @spec signature_base_string(String.t, String.t, Map.t) :: String.t
  def signature_base_string(method, base_url, collected_params) do
    [String.upcase(method), encode(base_url), encode(collected_params)]
    |> Enum.join("&")
  end

  @doc """
  Secrets to identify the application and user
  """
  @spec generate_signing_key(String.t, String.t) :: String.t
  def generate_signing_key(consumer_secret, access_token_secret) do
    encode(consumer_secret) <> "&" <> encode(access_token_secret)
  end

  @doc """
  Calculates the signature using HMAC-SHA1
  """
  @spec calculate_signature(String.t, String.t) :: String.t
  def calculate_signature(signed_key, signed_base_string) do
    :crypto.hmac(:sha, signed_key, signed_base_string) |> :base64.encode
  end

  @doc """
  Creates an autorhize request headers

    * consumer_key - Identifies the application
    * nonce - Unique identify generated by the application
    * timestamp - Indicates when the request was created
    * signature - A value which generated by running all the other request
        paramteres and two secrets values, through a signing algorithm.
    * oauth_token - Represents user permissions

  """
  # @spec authorize_request_headers(Headers.t, String.t, String.t) :: Map
  def authorize_request_headers(%Headers{} = auth_headers, signature, token) do
    Map.merge(auth_headers, %{oauth_token: token, oauth_signature: signature})
  end

  @doc """
  Builds the header string

    * auth_headers - Map of the authorization headers
  """
  @spec build_header_string(Headers.t) :: String.t
  def build_header_string(%Headers{} = auth_headers) do
    headers = auth_headers
      |> Map.from_struct
      |> Enum.map(fn x ->
        x |> elem(0) |> to_string |> to_charlist
        |> Enum.concat('=')
          |> Enum.concat('"')
        |> Enum.concat(x |> elem(1) |> to_string |> to_charlist)
          |> Enum.concat('"')
      end)
      |> Enum.join(", ")
      "OAuth " <> headers
  end

  def request(:get, url, headers) do
    :inets.start()
    :ssl.start()
    :httpc.request(:get, {url, headers}, [], 'application/json')
  end

  def request(:post, url, headers) do
    :inets.start()
    :ssl.start()
    :httpc.request(:post, {url, headers, 'application/json', []}, [], [])
  end

  defp encode({q, v}), do: {encode(q), encode(v)}
  defp encode(str), do: URI.encode(str, &URI.char_unreserved?/1)

  defp oauth_nonce do
    Regex.scan(~r/[a-zA-Z0-9]/,
      :base64.encode(:crypto.strong_rand_bytes(20)))
    |> Enum.join
  end

  defp timestamp do
    {mega, sec, _micro} = :os.timestamp
    mega * 1000000 + sec
  end
end
